\documentclass{sigplanconf}
\usepackage{amsmath}
\usepackage{fancyvrb}
\usepackage{url}


\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{2015} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}


\title{Title Text}

\authorinfo{Iavor S. Diatchki}
           {Galois Inc.}
           {iavor.diatchki@gmail.com}

\maketitle

\begin{abstract}
We present a technique for integrating GHC's type-checker with the
functionality provided by an SMT solver.  The technique was developed
to add support for reasoning about type-level functions on natural
numbers, and so our implementation mainly uses the theory of linear
arithmetic.  The technique, however, is more general and makes it
possible to experiment with other decision procedures supported by
the SMT solver.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

\section{Introduction}

For a few years now, there has been a steady push in the Haskell
community to explore and extend the type system, slowly approximating
functionality available in dependently typed languages
\cite{Eisenberg2012,Lindley2013,Eisenberg2014}.  The additional
expressiveness enables Haskell programmers to express more
invariants at compile time, which makes it easier to develop
reliable software, and also makes Haskell a nice language
for embedding domain specific languages \cite{ivory-experience}.
The Haskell compiler is not just a translator, but it also
serves as a tool that analyzes the program, and helps
finds common mistakes early in the development cycle.

Unfortunately, the extra expressiveness comes at a cost:
Haskell's type system is by no means simple. Writing
programs that make use of invariants encoded in the
type system can be complex and time consuming.  For
example, often one spends a lot of time proving simple theorems
about arithmetic which, while important to convince the compiler
that various invariants are preserved, contribute little to
the clarity of the algorithm being implemented \cite{Lindley2013}.

Given that in many cases the proofs constructed by the programmers
tend to be fairly simple, we can't help but wonder if there might
be a away to automate them away, thus gaining the benefits of
static checking, but without cluttering the program with trivial
facts about, say, arithmetic.  This paper presents a technique
to help with this problem: we show one method of integrating
an SMT solver with GHC's type checker.  While we present
the technique in the context of Haskell and GHC, the technique
should be applicable to other programming languages and compilers too.


\section{Background}

\subsection {SMT Solvers}

SMT solvers, such as CVC4 \cite{cvc4}, Yices \cite{yices}, and Z3
\cite{z3}, implement a wide collection of decision procedures that
work together to solve a common problem.  They have proved a useful
tool in both software and hardware verification.  In this Section,
we present a very brief introduction to the core functionality
of a typical SMT solver---readers familiar with the tools could
skip this Section.

From a user's perspective, the core functionality of an SMT solver is fairly
simple: we may declare uninterpreted constants, assert formulas,
and check if the asserted formulas are {\em satisfiable}.  Checking
for satisfiability simply means that we are asking the
question: are there concrete values for the uninterpreted constants
that make all asserted formulas true.  Here is an example, using
the notation of the SMTLIB standard \cite{smtlib2}

\begin{Verbatim}
(declare-fun x () Int)
(assert (>= x 0))
(assert (= (+ 3 x) 8))
(check-sat)
\end{Verbatim}

The example declares a constant, $x$, asserts some formulas
about it, and then asks the solver if the asserted formulas are
satisfiable.  In this case, the answer is affirmative, as choosing
$5$ for $x$ will make all formulas true.  Indeed, if an
SMT solver reports that a set of formulas is satisfiable, typically
it will also provide a {\em satisfying assignment}, which maps
the uninterpreted constants to concrete values that make the
asserted formulas true.

It is common to use the same machinery for proving the validity of
universally quantified formulas by looking for counter-examples.
For example, if we want to prove that $\forall x. (3 + x = 8) \implies x = 5$,
then we can use the SMT solver to try to find some $x$ that contradicts
the formula:

\begin{Verbatim}
(declare-fun x () Int)
(assert (= 3 x) 8)
(assert (not (= x 5)))
(check-sat)
\end{Verbatim}

To invalidate an implication, we need to assume the premise, and try to
invalidate the conclusion, which is why the second assertion in the
example is negated. In this case the SMT solver will tell us that the
asserted formulas are not satisfiable, which means that there are no
counter examples to the original formula and, therefore, it must be valid.


\subsection{GHC's Constraint Solver}

In this Section, we present a brief overview of some of the functionality
in GHC's constraint solver.  The full details \cite{outsidein} are beyond
the scope of this paper.

\paragraph{Implication Constraints.}
During type inference, GHC uses {\em implication constraints}, which do
not appear in Haskell source code directly. An implication constraint is,
roughly, of the form $G\implies W$, where $W$ is a collection
of constraints that need to be discharged, and $G$ are assumptions that
may be used while discharging $W$.  In the GHC source code, the constraints
in $G$ are referred to as {\em given constraints}, while the ones in $W$ are
known as {\em wanted constraints}.  The intuition behind an implication
constraint is that $W$ contains the constraints that were collected
while checking a program fragment, while the constraints in $G$ are local
assumptions that are only available in this particular piece of code.
For example, if we are checking the body of a case branch that matches
on a GADT constructor, then $G$ would be assumptions that we
obtain from the constructor, while $W$ would be constraints collected
while analyzing the body of the branch.

\paragraph{The Constraint Solver Pipeline.}
The constraint solver has two central pieces of state: the {\em work queue},
and the {\em inert set}.  The work queue contains constraints that need to be
processed, while the inert set contains constraints that have already
been processed.  Constraints are removed---one at a time---from the work queue,
and {\em interacted} with the solver's state.  In the process of interaction
we may solve a wanted constraint, possibly adding new constraints to the
work queue, or notice that a constraint is impossible to solve and record
an error, or---if nothing interesting happens---we add the constraint
to the inert set.  It is also possible that during interaction a previously
inert constraint may be reactivated in an "improved" form and re-inserted
in the work queue.  A single invocation of the constraint solver keeps
interacting constraints until the work queue is empty and all constraints
are in the inert set.

\paragraph{Derived Constraints.}


\section{Type Checker Plug-Ins}


\section{Algorithm}

\subsection{Idnetifying Constraints that Belong to the Theory}

\subsection{Consistency and Improvement}

\subsection{Simplifying Constraints}



Given an implication constraint: $G\implies W$.
\begin{enumerate}
\item Identify constraints in the theory
\item Name sub-terms that are outside the theory
\item Assume $G$
\item Check for satisfiability
  \begin{itemize}
  \item If unsat, implication is trivial, record error
  \item If sat, use model for improvement
  \end{itemize}
\item ...
\end{enumerate}


\section{A Modular Type Checker}

Relation between type-checker and
the Nelson-Oppen method for combining
decision procedures.


\section {Conclusions}



\bibliographystyle{abbrvnat}
\bibliography{refs}




% 
% % The bibliography should be embedded for final submission.
% 
% \begin{thebibliography}{}
% \softraggedright
% 
% \bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
% P. Q. Smith, and X. Y. Jones. ...reference text...
% 
% \end{thebibliography}


\end{document}

